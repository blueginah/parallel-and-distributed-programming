/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculate.h"
#include <math.h>

#define INPUT_MAX 300
#define EPSILON 0.000000001

void
calculate_prog_1(char *host)
{
	CLIENT *clnt;
	float  *result_1;
	input  add_1_arg;
	float  *result_2;
	input  sub_1_arg;
	float  *result_3;
	input  mul_1_arg;
	float  *result_4;
	input  div_1_arg;
    float a, b;
    int i, j, k, cnt=0, opcnt=0, calculated=0, validop=-1, validnum1=-1, validnum2=-1, validnum=-1, flag=0, is_div =0;
    int is_op = 0, num_cnt = 0, input_num = 0, is_num=0, m = 1, number =0, is_minus=0,num_tmp=0, int_answer = 0;
    char op, in, tmp;
    char input[INPUT_MAX];
    double float_result;
    valid arr[100];
    oper oparr[100];

#ifndef	DEBUG
	clnt = clnt_create (host, CALCULATE_PROG, CALCULATE_VERS, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

    printf("test\n");

    for(i = 0; i < 100; i++)
    {
        arr[i].v=0;
        arr[i].n=0;
        oparr[i].v=0;
        oparr[i].op='\0';
    }
    ///////
    for(i = 0; i < INPUT_MAX; i++)
        input[i] = '\0';
    for(i = 0; i < INPUT_MAX; i++)
    {
        scanf("%c", &in);
        if(in == '\n') break;
        input_num++;//total input string num
        input[i] = in;
    }

    for(i = 0; i < input_num; i++)
    {
        tmp = input[i];
        if('0' <= input[i] && input[i] <= '9')
        {
            if(is_op) is_op = 0;
            if(!is_num)
            {
                is_num = 1;
                num_cnt = 1;
            }//숫자의 시작
            else
            {
                num_cnt++;
            }
        }
        else if(tmp == '+' || tmp == '/' || tmp == '*' || tmp == '-')
        {
            if(tmp == '/') is_div = 1;
            if(is_num)
            {
                is_op = 1;
                is_num = 0;
                number = 0;
                num_tmp = num_cnt;

                for(j = i-num_cnt; j < i; j++)
                {
                    m=1;
                    for(k = 0; k < num_tmp-1; k++)
                        m *= 10;
                    number += m*(input[j]-'0');
                    num_tmp--;
                }
                if(is_minus)
                {
                    number = number*(-1);
                    is_minus = 0;
                }
                ///save number with proper index
                arr[cnt].n = number;
                //arr[cnt-1].n = number;
                oparr[opcnt].op = tmp;
                cnt++;
                opcnt++;
                //save operator with proper index
                num_cnt = 0;

            }//operator
            else
            {
                is_minus = 1;
            }//unary operator
        
        }
        else
        {
            printf("Input ERROR!!\n\n");
            exit(0);    
        }
        if(i == input_num-1)
        {
            if(is_num)
            {
                is_num = 0;
                number = 0;
                num_tmp = num_cnt;

                for(j = i-num_cnt+1; j<=i; j++)
                {
                    m=1;
                    for(k = 0; k < num_tmp-1; k++)
                        m*=10;
                    number += m*(input[j]-'0');
                    num_tmp--;
                }
                if(is_minus)
                {
                    number = number*(-1);
                }
                ///save number with proper index
                //////@@arr[cnt-1].n = number;
                arr[cnt].n = number;
                cnt++;
                //save operator with proper index
            }//operator
        
        }


    }

    for(i = 0; i < cnt; i++)
        arr[i].v=1;
    for(i = 0; i < opcnt; i++)
        oparr[i].v=1;
    //initialize valid bit

    validop=-1;
    for(i = 0; i < opcnt; i++)
    {
        if(oparr[i].v == 1)
        {
            validop++;//validop==0 at first time
            if(oparr[i].op == '*')
            {
                flag=0;
                validnum1=-1;
                validnum2=-1;
                validnum=-1;

                for(j = 0; j < cnt; j++)
                {
                    if(arr[j].v == 1) validnum++;
                    if(validnum == validop)
                    {
                        validnum1=j;
                        //validnum1=validnum;
                        for(k = j+1; k < cnt; k++)
                        {
                            if(arr[k].v == 1)
                            {
                                validnum2 = k;
                                break;
                            }
                        }
                        break;
                    }
                }
                mul_1_arg.n1 = arr[validnum1].n;
                mul_1_arg.n2 = arr[validnum2].n;
	            result_3 = mul_1(&mul_1_arg, clnt);
	            if (result_3 == (float *) NULL) {
		            clnt_perror (clnt, "call failed");
	            }
                arr[validnum1].n = *result_3;
                arr[validnum2].v=0;
              
                oparr[i].v=0;
                validop--;
            }
            else if(oparr[i].op == '/')
            {
                flag=0;
                validnum1=-1;
                validnum2=-1;
                validnum=-1;
                for(j = 0; j < cnt; j++)
                {
                    if(arr[j].v == 1) validnum++;
                    if(validnum == validop)
                    {
                        validnum1=j;
                        //validnum1=validnum;
                        for(k = j+1; k < cnt; k++)
                        {
                            if(arr[k].v == 1)
                            {
                                validnum2 = k;
                                break;
                            }
                        }
                        break;
                    }
                }
                div_1_arg.n1 = arr[validnum1].n;
                div_1_arg.n2 = arr[validnum2].n;

                if(arr[validnum2].n == 0)
                {
                    printf("Cannot divide with zero!!\n");
                    exit(0);
                }
	            result_4 = div_1(&div_1_arg, clnt);
	            if (result_4 == (float *) NULL) {
		            clnt_perror (clnt, "call failed");
	            }

                arr[validnum1].n = *result_4;
                arr[validnum2].v=0;
              
                oparr[i].v=0;
                validop--;

            }
        }

    }//calculate mul & div
    validop=-1;
    for(i = 0; i < opcnt; i++)
    {
        if(oparr[i].v == 1)
        {
            validop++;
            if(oparr[i].op == '+')
            {

                flag=0;
                validnum1=-1;
                validnum2=-1;
                validnum=-1;
                for(j = 0; j < cnt; j++)
                {
                    if(arr[j].v == 1) validnum++;
                    if(validnum == validop)
                    {
                        validnum1=j;
                        //validnum1=validnum;
                        for(k = j+1; k < cnt; k++)
                        {
                            if(arr[k].v == 1)
                            {
                                validnum2 = k;
                                break;
                            }
                        }
                        break;
                    }
                }
                add_1_arg.n1 = arr[validnum1].n;
                add_1_arg.n2 = arr[validnum2].n;
	            result_1 = add_1(&add_1_arg, clnt);
	            if (result_1 == (float *) NULL) {
		            clnt_perror (clnt, "call failed");
	            }

                arr[validnum1].n = *result_1;
                arr[validnum2].v=0;
              
                oparr[i].v=0;
                validop--;
            }
            if(oparr[i].op == '-')
            {
                flag=0;
                validnum1=-1;
                validnum2=-1;
                validnum=-1;
                for(j = 0; j < cnt; j++)
                {
                    if(arr[j].v == 1) validnum++;
                    if(validnum == validop)
                    {
                        validnum1=j;
                        //validnum1=validnum;
                        for(k = j+1; k < cnt; k++)
                        {
                            if(arr[k].v == 1)
                            {
                                validnum2 = k;
                                break;
                            }
                        }
                        break;
                    }
                }
                sub_1_arg.n1 = arr[validnum1].n;
                sub_1_arg.n2 = arr[validnum2].n;
	            result_2 = sub_1(&sub_1_arg, clnt);
	            if (result_2 == (float *) NULL) {
		            clnt_perror (clnt, "call failed");
	            }
                arr[validnum1].n = *result_2;
                arr[validnum2].v=0;
              
                oparr[i].v=0;
                validop--;
            }
        }

    }//calculate add & sub
    for(i = 0; i < cnt; i++)
    {
        if(arr[i].v == 1)
        {
            if(is_div)
                printf("The answer is : %.3f\n", arr[i].n);
            else
                printf("The answer is : %d\n", (int)arr[i].n);

            /*
            if(arr[i].v-(int)arr[i].v != 0)
                printf("The answer is : %d\n", (int)arr[i].n);
            else
                printf("The answer is : %f\n", arr[i].n);
            //float_result = (double)arr[i].v;
            if(arr[i].v - (float)((int)arr[i].v) <= EPSILON && arr[i].v- (float)((int)arr[i].v) >= (-1)*EPSILON)
                printf("The answer is : %d\n", (int)arr[i].n);
            else*/
                //printf("The answer is : %f\n", arr[i].n);
        }
    }


#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}
	host = argv[1];
	calculate_prog_1 (host);
exit (0);

}
